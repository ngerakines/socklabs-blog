<!DOCTYPE html>
<html>
  <head>
	<link href="/css/style.css" media="screen" rel="stylesheet" type="text/css" />
    <title>Nick's Blog | Using Test::Harness with etap</title>
  </head>
  <body>
	<a href="/"><h1>Nick's Blog</h1></a>
	<div id="content">
		<div id="posts">
			<h2><a alt="Using Test::Harness with etap" href="/2008/12/30/using_test_harness_and_etap.html">Using Test::Harness with etap</a></h2>
			<em id="sub_h2">30 December 2008</em>
		 	<p>This isn't a beginner's walk through. It assumes you know how to use and read Erlang as well as install Erlang and Perl libraries</p>

<p>I love <a href="http://search.cpan.org/dist/TAP/">TAP</a>. TAP is a protocol used to create and interact with testing frameworks. The general idea is that your unit tests interact with a TAP client which outputs the TAP protocol that is then consumed by a TAP server. What it boils down to is a really simple text based structure used to convey unit test results, with a few added bonuses here and there.</p>

<p>With <a href="http://github.com/ngerakines/etap/tree/master">etap</a> and Perl's <a href="http://search.cpan.org/~andya/Test-Harness/">TAP::Harness</a> we can create really slick test result output and move closer to having a continuous integration build environment. Before you get ahead of yourself, you'll need to make sure that you've got etap downloaded and in your Erlang lib path. You'll also have to install TAP::Harness and it's dependancies.</p>

<p>To demonstrate how this is done, we'll use the <a href="http://github.com/ngerakines/erlang_protobuffs/tree/master">erlang_protobuffs</a> library. This library is composed of two modules that provide functionality through direct interaction with their exported functions. They don't extend any OTP behaviors and have very few side effects. The project's sources are contained in the <code>src</code> directory and it's tests in the <code>t</code> directory. There is also a support directory that provides the Makefile include for building the actual modules.</p>

<p>The <code>test</code> target in the root Makefile calls the <code>prove</code> command with the verbose flag and a glob of the *.t files in the <code>t</code> diretory.</p>

<pre><code>test: all
    prove -v t/*.t
</code></pre>

<p>The actual tests for the project are <a href="http://erlang.org/doc/man/escript.html">escript</a> files with the .t extension. Using the escript hash bang lets us treat each file as it's own complete unit test. They can be run in any order and have their own configuration and directives. Below is the protobuffs_t_001.t file.</p>

<pre><code>#!/usr/bin/env escript
%% -*- erlang -*-
%%! -pa ./ebin -sasl errlog_type error -boot start_sasl -noshell

main(_) -&gt;
    etap:plan(8),
    etap_can:loaded_ok(protobuffs, "module 'protobuffs' loaded"),
    etap_can:can_ok(protobuffs, encode),
    etap_can:can_ok(protobuffs, encode, 3),
    etap_can:can_ok(protobuffs, decode),
    etap_can:can_ok(protobuffs, decode, 2),
    etap_can:loaded_ok(protobuffs_compile, "module 'protobuffs_compile' loaded"),
    etap_can:can_ok(protobuffs_compile, scan_file),
    etap_can:can_ok(protobuffs_compile, scan_file, 1),
    etap:end_tests().
</code></pre>

<p>Lines 1, 2 and 3 are used by the shell and escript command to set any Erlang vm options necessary. In this case we want to include the <code>ebin</code> directory, start sasl with minimal logging and disable the shell.</p>

<p>The <code>main/0</code> function is called escript with whatever relevant arguments that may apply, but we don't care about them so we ignore them for now. Here we perform several tests to assert that the project's modules load and export the proper functions.</p>

<p>The <code>etap:plan/1</code> and <code>etap:end_tests/0</code> functions wrap the <code>etap*:*</code> function calls and is used to define the test plan. At this point etap is not designed to work without finite plans.</p>

<pre><code>#!/usr/bin/env escript
%% -*- erlang -*-
%%! -pa ./ebin -sasl errlog_type error -boot start_sasl -noshell

-record(person, {name, address, phone_number, age, location}).

main(_) -&gt;
    etap:plan(1),
    etap:is(protobuffs_compile:scan_file("t/simple.proto"), ok, "simple.proto compiled"),
    compile:file("simple_pb.erl"),
    Data = [{1, &lt;&lt;"Nick"&gt;&gt;, string}, {2, &lt;&lt;"Mountain View"&gt;&gt;, string}, {3, &lt;&lt;"+1 (000) 555-1234"&gt;&gt;, string}, {4, 25, int32}],
    BinData = erlang:iolist_to_binary([protobuffs:encode(Pos, Value, Type) || {Pos, Value, Type} &lt;- Data]),
    #person{ name = &lt;&lt;"Nick"&gt;&gt;, address = &lt;&lt;"Mountain View"&gt;&gt;, phone_number = &lt;&lt;"+1 (000) 555-1234"&gt;&gt;, age = 25} = simple_pb:decode_person(BinData),
    BinData = simple_pb:encode_person(#person{ name = &lt;&lt;"Nick"&gt;&gt;, address = &lt;&lt;"Mountain View"&gt;&gt;, phone_number = &lt;&lt;"+1 (000) 555-1234"&gt;&gt;, age = 25}),
    etap:end_tests().
</code></pre>

<p>In the protobuffs_t_005.t file you see that you can do things like define records. In this test unit we call several of the library's exported functions and test some of the more complex functionality. The <code>protobuffs_compile:scan_file/1</code> function actually writes several files which are then compiled by <code>compile:file/1</code> and used by subsequent test unit function calls.</p>

<p>The output of the <code>make test</code> command, as processed by the TAP::Harness perl module, is very clean.</p>

<pre><code>mbp:erlang_protobuffs ngerakines$ make test
mkdir -p ebin/
(cd src;make)
erlc -W -I ../include  +debug_info -o ../ebin protobuffs.erl
erlc -W -I ../include  +debug_info -o ../ebin protobuffs_compile.erl
prove t/*.t
t/protobuffs_t_001....ok   
t/protobuffs_t_002....ok   
t/protobuffs_t_003....ok   
t/protobuffs_t_004....ok   
t/protobuffs_t_005....ok   
t/protobuffs_t_006....ok   
All tests successful.
Files=6, Tests=17,  1 wallclock secs ( 0.04 usr  0.02 sys +  0.97 cusr  0.27 csys =  1.30 CPU)
Result: PASS
</code></pre>

<p>Depending on the error and severity, failed tests will either output in a similarly clean fashion or stop the entire suite from processing.</p>

<pre><code>mbp:erlang_protobuffs ngerakines$ make test
mkdir -p ebin/
(cd src;make)
erlc -W -I ../include  +debug_info -o ../ebin protobuffs.erl
erlc -W -I ../include  +debug_info -o ../ebin protobuffs_compile.erl
prove t/*.t
t/protobuffs_t_001....ok   
t/protobuffs_t_002....ok   
t/protobuffs_t_003.... Failed 1/3 subtests 
t/protobuffs_t_004....ok   
t/protobuffs_t_005....ok   
t/protobuffs_t_006....ok   

Test Summary Report
-------------------
t/protobuffs_t_003 (Wstat: 0 Tests: 3 Failed: 1)
  Failed test:  2
Files=6, Tests=17,  2 wallclock secs ( 0.04 usr  0.02 sys +  0.96 cusr  0.26 csys =  1.28 CPU)
Result: FAIL
make: *** [test] Error 1
</code></pre>

<p>The prove command has a number of options and arguments that augment test execution. Please refer to <code>prove --help</code> or the documentation available on CPAN for more information.</p>

<p>There are a few things to take note of. All of the paths to included and referenced files, such as the <code>simple.proto</code> file, are relative to where the <code>prove</code> command is called. In this case it's in the root directory as part of the <code>test</code> target. Also, for some more complex and lengthy tests, please read up on the escript documentation. The compile mode can be used to pre-compile the file before being called but has a few caveats that you should be aware of.</p>

		</div>
		<div id="sidebar">
	<div class="clear"></div>
	<div id="sidebar_content">
		<h2>Recently</h2>
		
			<h3 style="padding-top: 10px;"><a alt="Integrating Heman into CalendERL About Nothing" href="/2009/12/28/integrating_heman_into_calenderl_about_nothing.html">Integrating Heman into CalendERL About Nothing</a></h3>
			<em id="sub_h3">28 December 2009</em>
		
			<h3 style="padding-top: 10px;"><a alt="Lets create some Erlang standards, part one" href="/2009/11/24/lets_create_some_erlang_standards_part_one.html">Lets create some Erlang standards, part one</a></h3>
			<em id="sub_h3">24 November 2009</em>
		
			<h3 style="padding-top: 10px;"><a alt="2009 Erlang User Conference" href="/2009/11/12/EUC2009.html">2009 Erlang User Conference</a></h3>
			<em id="sub_h3">12 November 2009</em>
		
			<h3 style="padding-top: 10px;"><a alt="CalendERL About Nothing" href="/2009/11/01/calenderl_about_nothing.html">CalendERL About Nothing</a></h3>
			<em id="sub_h3">01 November 2009</em>
		
			<h3 style="padding-top: 10px;"><a alt="Globally Shared Queues" href="/2009/10/26/globally_shared_queues.html">Globally Shared Queues</a></h3>
			<em id="sub_h3">26 October 2009</em>
		
		<h2 style="padding-top: 20px;"><a href="/about/">About</a></h2>
		<h2 style="padding-top: 20px;"><a href="/projects/">Projects</a></h2>
		<h2 style="padding-top: 20px;"><a href="/archives/">Archives</a></h2>
	</div>
</div>

		<div id="disqus_thread"></div>
	</div>
	<script type="text/javascript" src="http://disqus.com/forums/socklabs-blog/embed.js"></script>
<noscript>
	<a href="http://disqus.com/forums/socklabs-blog/?url=ref">View the discussion thread.</a>
</noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
<script type="text/javascript">
//<![CDATA[
(function() {
	var links = document.getElementsByTagName('a');
	var query = '?';
	for(var i = 0; i < links.length; i++) {
	if(links[i].href.indexOf('#disqus_thread') >= 0) {
		query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
	}
	}
	document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/socklabs-blog/get_num_replies.js' + query + '"></' + 'script>');
})();
//]]>
</script>

	<div class="clear"></div>
	<div id="footer">
	<a href="/" alt="blog"><b>Blog</b></a>
	| <a href="http://socklabs.com">Socklabs</a>
	| <a href="http://twitter.com/ngerakines" alt="status">On Twitter</a>
	| <a alt="ngerakines on Facebook" href="http://facebook.com/ngerakines">on Facebook</a>
</div>
	</body>
</html>